<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Подготовка к техническому собеседованию 6 Jan 24</title>
	<link rel="icon" href="/course/images/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 0;
			color: #333;
			background-color: #f4f6f9;
		}
		.container {
			max-width: 1400px;
			margin: 40px auto;
			padding: 20px;
			background-color: #fff;
			border-radius: 8px;
			box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
		}
		h1, h2 {
			color: #2c3e50;
			text-align: center;
		}
		h1 {
			font-size: 2em;
			margin-bottom: 10px;
		}
		.accordion {
			margin-top: 20px;
			border-radius: 5px;
		}
		.accordion-item {
			border-top: 1px solid #ddd;
		}
		.accordion-title {
			padding: 15px;
			font-size: 18px;
			cursor: pointer;
			display: flex;
			justify-content: space-between;
			align-items: center;
			background-color: #e8f1fa;
			transition: background-color 0.3s;
		}
		.accordion-title:hover {
			background-color: #d3e7f9;
		}
		.accordion-content {
			padding: 15px;
			display: none;
			background-color: #ffffff;
			border-top: 1px solid #ddd;
		}
		.button-container {
			text-align: center;
			margin-top: 20px; /* Опционально, для отступа сверху */
		}
		.start-button {
			display: inline-block;
			padding: 12px 24px;
			font-size: 18px;
			color: #fff;
			background-color: #3498db;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			text-align: center;
			text-decoration: none;
			box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
			transition: background-color 0.3s ease, box-shadow 0.3s ease;
		}

		.start-button:hover {
			background-color: #2980b9;
			box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
		}
		.video-container {
			text-align: center;
			margin: 20px 0;
		}
		.accordion-icon {
			transition: transform 0.3s ease;
		}
		.accordion-title.active .accordion-icon {
			transform: rotate(180deg);
		}
		.icon-container {
			position: fixed;
			bottom: 20px;
			right: 20px;
			display: flex;
			flex-direction: column;
			gap: 10px;
		}
		.gray, .yellow, .blue {
			width: 45px;
			height: 45px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-size: 18px;
			color: #333;
			text-decoration: none;
			font-weight: bold;
			transition: transform 0.3s;
		}
		.gray { background-color: #bdc3c7; }
		.yellow { background-color: #f1c40f; }
		.blue { background-color: #3498db; color: #fff; }
		.gray:hover, .yellow:hover, .blue:hover {
			transform: scale(1.1);
		}
	</style>
	<script>
		function toggleAccordion(event) {
			const title = event.currentTarget;
			const content = title.nextElementSibling;
			content.style.display = content.style.display === 'block' ? 'none' : 'block';
			title.classList.toggle('active');
		}
	</script>
</head>
<body>
	<div class="container">
		<h1>Подготовка к техническому собеседованию 6 Jan 24</h1>
	<div class="course-intro">
		<div class="accordion">
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Информация обо мне
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Manual QA Engineer,<br>
					В IT с 2009 года в TulaCo c 2012-го года,<br>
					41 год,<br>
					до TulaCo поработал в 2-х outsource компаниях,<br>
					Уровень Английского Pre-Intermediate,<br>
					Был на собеседовании техническом последний раз в 2010 году.<br>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Проекты и роль в проектах
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					The Studio System<br>
					База данных по Фильмам, Компаниям, Людям.<br>
					Большое количество данных в базе, при этом не очень много клиентов.<br>
					Несколько раз переписывали проект.<br>
					Большое количество подпроектов. Несколько CMS (Maching, Images, Data, Acess) iOS app где то штук 8 разных подпроектов.<br>
					Проработал там в общей сложности лет 8-9 с перерывами т.к. заказчик уходил<br>
					Большую часть времени работал на проекте 1, На пике на проекте работало около 15 человек, тогда брали 2-го QA<br>
					В митингах не участвовал вообще.<br>
					Вся разработка была в то время в Могилеском офисе и все работали из офиса. Так что все что было надо или непонятно решалось офлайн.<br>
					Общался через Jira если надо было уточнить требования какие то у продект овнеров. Хотя в начале была какая то другая система для ведения проектов, я не помню что это было но точно что то плохое.<br>
					Писали какие то тест кейсы в TestLink но это было от безделия когда не было силььно работы и заканчивалось когда работа появлялась.<br>
					Было 3 Environment QA, STG, Prod. Делали Релиз кандадата, ложили на STG там его смотрел заказчик или не смотрел и в какой то момент я получал сообщение что мы в прод вышли пробегись по проду.<br>
					У меня было несколько чек листов, условно там на 15 минут на 30 и на час. Проводил Smoke на проде. Отписывался что все прошло/или не прошло. После этого смотрел на новые фичи фиксы которые были залиты.<br>
					Конечно бывало что какие то баги пролазили на прод но это было не часто. Ну по багам которые обнаружились только на проде смотрели по ситуации или хотфиксили или уже в следующую сборку фиксы шли.<br>
					Там более менее активно использовал базу. Обычно хватало простых селектов или хранимку какую то надо было дернуть после каких то действий что б данные пересчитались.
					Если надо было сделать какой то join шел в соседний кабинет, из за того что это надо было условно раз в пол года а не использовалось там например раз в неделю то на той неделе когда я писал или мне помогали написать запрос я пониал как он работает и.т.д а через время все забывал.<br>
					Несколько раз делал нагрузочное тестирование в JMeter. Как оказалось сделать нагрузочный тест в JMeter не так сложно как понять результаты и понять на сколько ты на самом деле нагрузил систему.<br>
					C CI/CD я не работал. Авто тестами я не занимался по той же причине что и тест кейсами. Приложения несколько раз переписывалось, я был там в основном 1 тестировщик и поддерживать все это дело было +- нереально в одно лицо, всех устраивало что происходит.<br>
					тестировал iOS App. <br>
					На TSS я работал с Димой Дикуном, с Вадимом Чуськовым, с Максимом Яковлевым, с Олегом Ганиным, с Юрой Янковским.<br><br><br>
					
					StyleRow<br>
					Приложение для дизайнеров.<br>
					Стартап с процессами.<br>
					Проработал там около 2-х лет<br>
					На проекте работало где то около 10 разработчиков и 5 QA<br>
					Налаженные процессы. Посмотрел как это все выглядит.<br>
					Четкое планирование, релизи раз в 2 недели. Полное покрытие тестами нового функционала, огромная регрессия на 2-3 дня. Смоук тест на 4 часа после релиза).<br>
					Лид делил задачи между QA которые попали в спринт, после этого каждый писал тесты по своей функциональности. И было ревью тестов.<br>
					После того как девелоперы заканчивали с разработкой проводилось тестирование на QA,<br>
					Создавались баги что то уточнялось еще, какие то тесты могли меняться.<br>
					Делался кодфриз фиксились баги и то что успешно прошло тестирование попадало как релиз кандидат на STG.<br>
					На STG проводилась регрессия которая несколько дней занимала. Наверно мы пару тысяч тест кейсов гоняли командой за спринт.<br>
					Ла, автотесты и все такое, но это стартап, который довольно живой и функционал и UI менялись / переделывались<br>
					Авто тесты были но я ими не занимался. Не было времени и задачи такой.<br>
					Работали в TestRail Написал кучу чеклистов (использовались у нас вместо тест кейсов).<br>
					Большое внимание уделялось UI т.е. там 2-3 пикселя что то куда то уехало или больше/меньш еще ок а условно 4 уже бага. (Figma, PerfectPixel)<br>
					Каждый день на дейлике отсматривались ВСЕ новые баги, обсуждался приоритет. Что то попадало в спринт, что то наоборот выкидывали из спринта.
					Было правило по багам - то что относится к фичам в текущем спринте в спринт, то что не относится 50/50 зависило от загрузки и критичности бага.
					По размаху самого приложения и по маштабам разработки оно раза в 2 было меньше чем TSS при этом тут было 4 QA.<br><br><br>
					
					Twinbox<br>
					Widget для поиска информации в подкастах. И дашборд для подкастеров.<br>
					Это по сути класический стартап в котором скорость важнее качества.<br>
					Для каких то новых фич, лучше мы выйдем с багой и потом её подправим (если она будет) при этом максимально быстро сможем получить фидбэк, чем будем искать багу которой нет.<br>
					Проработал там около года и продолжаю частично работать<br>
					Команда человек 7 я тестировал, и много чем еще занимался попутно и паралельно<br>
					Не для всего был UI поэтому довольно плотно работал с Postman.<br>
					Несколько раз делал нагрузочные тесты. Пользователей было не много интересовало сколько очень примерно система выдержит и какой в среднем время на ответ пользователю.
					Т.е. Заказчики едут на конфу какую то, надо было понять сколько мы гарантированно можем пользователей одновременно держать. Когда времени совсем не было были примитивные тесты. +- одновременно через браузер 20 пользователей создавалось. Потом проводили уже нормальные тесты более менее (фронт сказал что на моей стороне проблем не будет если бэк данные отдаст)) Сделал коллекцию прописал какой то сценарий запросами, потестировали вместе с бэком. Опять таки без помощи разработчика сложно что то понять, если что то очевидное то да понятно но как правило все сложнее.
					Увидел все процессы изнутри. (Я имею ввиду то не было ваще никакой закрытой информации от меня). Потому что до этого прилетает какая то задача с каким то приоритетом кому и зачем она нужна было понятно не до конца. <br>
					Тестировал страйп. Тестировал GPT.<br>
					При тестировании GPT важно во первых что каждый запрос стоит денег. А еще важно понимать что есть куча факторов влияющих на ответ. И вишенка на торте ты спрашиваешь 4 раза, один раз отвечает хорошо, 2 раза нормально, 1 раз плохо естественно это все на одной машине с одинаковыми настройками) <br>
					Аналитикой не занимался, В основном смотрел то что происходит в LangSmith<br>
					Доступ к базе мне не дали, хоть я и просил с правами на чтение себе доступ к QA<br>
					PostgresQL у нас по моему была база, бэк часть на питоне часть еще на чем то. <br>
				</div>
			</div>
	</div>
		
	<h2>Виды тестирования</h2>
		<div class="accordion">
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					<strong>Функциональное тестирование</strong>
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>Функциональное тестирование</strong> - это процесс проверки того, что система или ее компоненты выполняют заявленные функции правильно, основываясь на функциональных спецификациях.<br>
					
					<h4>Классификация функционального тестирования:</h4>
							1. Smoke Testing: Базовая проверка функциональности, чтобы убедиться, что приложение запускается и работает без критических ошибок.<br>
							2. Sanity Testing: Проверка работоспособности новых функций или багфиксов без глубокого тестирования.<br>
							3. Regression Testing: Повторное тестирование функций после изменения кода, чтобы убедиться, что изменения не сломали существующую функциональность.<br>
							4. Integration Testing: Проверка взаимодействия между различными модулями системы.<br>
							
					<h4>Ключевые этапы функционального тестирования:</h4>
							1. Анализ требований: понимание того, как должна работать каждая функция.<br>
							2. Разработка тест-кейсов: создание сценариев тестирования, описывающих входные данные и ожидаемые результаты.<br>
							3. Исполнение тестов: выполнение тестов вручную или с использованием автоматизации.<br>
							4. Сравнение результатов: сопоставление фактического поведения системы с ожидаемым.<br>
							5. Документирование дефектов: фиксация найденных ошибок для последующего исправления.<br>
							
					<h4>Примеры функционального тестирования // Веб-приложение (например, интернет-магазин):</h4>
							1. Авторизация и регистрация: Проверка, что пользователь может зарегистрироваться, войти в аккаунт с правильными данными, а также что система показывает ошибку при вводе неверных данных.<br>
							2. Поиск товаров: Проверка работы поиска по ключевым словам, фильтров и сортировки.<br>
							3. Оформление заказа: Проверка добавления товаров в корзину, выбора способа доставки, ввода данных и успешной оплаты.<br>
							4. Электронная почта: Проверка отправки подтверждения на email после успешной регистрации или оформления заказа.<br>
				</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Smoke Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Smoke Testing - это вид тестирования, направленный на проверку базовой работоспособности приложения. Этот процесс позволяет определить, функционирует ли приложение достаточно стабильно, чтобы продолжить более глубокое тестирование.
					<h4>Цели Smoke Testing:</h4>
						1. Раннее выявление критических дефектов: Проверка на самых базовых уровнях помогает быстро определить, можно ли продолжать дальнейшее тестирование или требуется доработка.<br>
						2. Экономия времени: Smoke Testing выполняется быстро, позволяя избежать вложения ресурсов в тестирование системы, которая явно не готова к проверкам.<br>
						3. Уверенность в стабильности сборки: Оно подтверждает, что ключевые функции работают так, как ожидается.<br>
						
					<h4>Когда проводится Smoke Testing:</h4>
						1. После получения новой сборки программного обеспечения.<br>
						2. Перед началом более детального тестирования (например, функционального или регрессионного).<br>
						3. В условиях ограниченного времени, когда нужно удостовериться в работоспособности основных функций.<br>
						
					<h4>Особенности Smoke Testing:</h4>
						1. Проверяет только основные и критически важные функции приложения.<br>
						2. Выполняется вручную или с помощью автоматизации (в зависимости от процесса разработки).<br>
						3. Является "поверхностным" тестированием — не затрагивает детали реализации.<br>
						
					<h4>Пример Smoke Testing:</h4>
						Предположим, мы тестируем интернет-магазин. Основные проверки в рамках Smoke Testing могут включать:<br>
						1. Успешный вход в систему.<br>
						2. Добавление товаров в корзину.<br>
						3. Оформление заказа.<br>
						4. Отправка запроса на восстановление пароля.<br>
						5. Загрузка главной страницы.<br>
						Если хотя бы одна из этих базовых функций не работает, тестирование прекращается, и сборка отправляется разработчикам на исправление.<br>
						
					<h4>Преимущества Smoke Testing:</h4>
						1. Экономия времени и ресурсов: Обнаружение критических дефектов на раннем этапе предотвращает более глубокое тестирование нерабочей сборки.<br>
						2. Быстрое обнаружение проблем: Тестировщики и разработчики могут оперативно выявить и устранить основные дефекты.<br>
						3. Стабильность процесса тестирования: Убедившись в готовности системы, команда может уверенно приступать к более глубоким проверкам.<br>
				</div>
			</div>
			<div class="accordion-title" onclick="toggleAccordion(event)">
					Sanity Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Sanity Testing: - (проверка здравого смысла) — это вид тестирования, направленный на быструю проверку отдельных функциональностей приложения после внесения изменений или исправлений. <br>
					Основная цель — убедиться, что недавно добавленные или исправленные функции работают правильно, и эти изменения не нарушили критически важные части системы.<br>
					
					<h4>Ключевые характеристики Sanity Testing:</h4>
						1. Ограниченный объем:<br>
							1.1. Проверяется только та область, в которую были внесены изменения, и смежные области, потенциально затронутые этими изменениями.<br>
							1.2. Это не полное тестирование системы.<br>
						2. Фокус на функциональности:<br>
							2.1. Тестируется работоспособность новых или измененных функций, чтобы удостовериться, что они реализованы правильно.<br>
						3. Поверхностный и быстрый:<br>
							3.1. Sanity Testing обычно выполняется вручную и не требует глубокого анализа системы.<br>
						4. Когда применяется:<br>
							4.1. После внесения исправлений дефектов (bug fixes).<br>
							4.2. После небольших изменений в коде, когда полное регрессионное тестирование не требуется.<br>
							
					<h4>Пример Sanity Testing:</h4>
						Предположим, разработчики исправили баг, из-за которого пользователь не мог добавить товар в корзину. Во время Sanity Testing тестировщик:<br>
						1. Проверяет, работает ли теперь добавление товара в корзину.<br>
						2. Убеждается, что удаление товара из корзины тоже не нарушено.<br>
						3. Проверяет, что корректно обновляется общая сумма заказа в корзине.<br>
						Если функциональность работает как ожидается, тестирование может быть продолжено в более широком объеме (например, регрессионное тестирование).<br>
						
					<h4>Цели Sanity Testing:</h4>
						1. Проверка функциональности исправлений: Убедиться, что конкретные изменения или исправления работают правильно.<br>
						2. Минимизация времени: Быстро подтвердить, что нет серьезных проблем, чтобы перейти к другим задачам.<br>
						3. Сохранение стабильности системы: Проверить, что изменения не создали новых ошибок в других частях системы.<br>
						
					<h4>Преимущества Sanity Testing:</h4>
						1. Экономия времени: Быстрая проверка позволяет выявить проблемы без выполнения полного цикла тестирования.<br>
						2. Уменьшение рисков: Помогает подтвердить, что исправления или изменения не сломали основную функциональность.<br>
						3. Фокус на актуальных областях: Тестирование ограничено тем, что действительно важно, что повышает его эффективность.<br>
						
					<h4>Недостатки:</h4>
						1. Ограниченный охват: Проверяются только измененные области, что может привести к пропуску ошибок в других частях системы.<br>
						2. Ручное выполнение: Обычно проводится вручную, что может быть менее эффективным по сравнению с автоматизацией.<br>
						
					<h4>Пример использования:</h4>
						Допустим, разработчик добавил новый способ оплаты — с помощью криптовалюты. Тестировщик в рамках Sanity Testing:<br>
						1. Проверяет, можно ли выбрать этот метод оплаты.<br>
						2. Проверяет, отправляется ли платеж правильно.<br>
						3. Убеждается, что старые методы оплаты (например, банковская карта) продолжают работать.<br>
						Если тесты прошли успешно, команда продолжает более детальное тестирование.
				</div>
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Regression Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Regression Testing (регрессионное тестирование) — это вид тестирования, направленный на проверку того, что новые изменения в коде (добавление новых функций, исправление багов, рефакторинг) не нарушили работоспособность уже существующих функций системы.
					
					<h4>Основные задачи Regression Testing:</h4>
						1. Убедиться, что внесенные изменения в код не вызвали регрессии (то есть повторного появления дефектов в ранее работающих функциях).<br>
						2. Проверить, что новые или измененные части системы взаимодействуют с существующими компонентами корректно.<br>
						3. Обеспечить стабильность и качество продукта после каждого обновления.<br>
						
					<h4>Когда проводится Regression Testing:</h4>
						1. Идентификация областей риска:<br>
							1.1. Определяются участки системы, которые могли быть затронуты изменениями.<br>
							1.2. Анализируются зависимости между модулями.<br>
						2. Создание набора регрессионных тестов:<br>
							2.1. Сюда входят тесты, покрывающие наиболее важные функции и сценарии.<br>
							2.2. Тесты могут быть функциональными, интеграционными или системными.<br>
						3. Создание набора регрессионных тестов:<br>
							3.1. Regression Testing часто автоматизируется для ускорения процесса, особенно при частых изменениях в коде.<br>
						4. Запуск тестов:<br>
							4.1. Тесты выполняются, чтобы убедиться, что все работает как раньше.<br>
						5. Анализ результатов:<br>
							5.1. Если тесты провалились, разработчики получают информацию о проблемных местах для исправления.<br>
							
					<h4>Подходы к Regression Testing:</h4>
						1. Полный регрессионный прогон:<br>
							1.1. Все существующие тесты выполняются повторно.<br>
							1.2. Используется при крупных изменениях, но занимает много времени и ресурсов.<br>
						2. Выборочный прогон:<br>
							2.1. Тестируются только те части системы, которые потенциально могли быть затронуты изменениями.<br>
							2.2. Экономит время и ресурсы, но требует тщательного анализа изменений.<br>
						3. Приоритетный прогон:<br>
							3.1. Тестируются только наиболее критичные функции.<br>
							3.2. Используется, если время ограничено.<br>
						
					<h4>Примеры Regression Testing:</h4>
						1. Добавление новой функции:<br>
							1.1. Вы добавляете новый модуль оплаты через криптовалюту.<br>
							1.2. При регрессионном тестировании проверяется, что старые методы оплаты (например, через банковскую карту) работают корректно.<br>
						2. Исправление дефекта:<br>
							2.1. Исправлен баг, из-за которого пользователь не мог загрузить изображение.<br>
							2.2. При регрессионном тестировании проверяются и другие функции, связанные с загрузкой файлов, чтобы убедиться, что исправление не вызвало новых проблем.<br>
						3. Оптимизация производительности:<br>
							3.1. Код системы оптимизируется для ускорения работы.<br>
							3.2. Проверяется, что все функции работают корректно после оптимизации.<br>
						
					<h4>Преимущества Regression Testing:</h4>
						1. Раннее обнаружение дефектов: Проблемы, вызванные изменениями, выявляются до выпуска продукта.<br>
						2. Поддержание стабильности: Убедившись, что изменения не нарушили существующие функции, команда может быть уверена в стабильности системы.<br>
						3. Уменьшение рисков: Тестирование предотвращает случайные регрессии, которые могли бы повлиять на пользователей.<br>
				</div>
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Integration Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Integration Testing (интеграционное тестирование) — это уровень тестирования, при котором проверяется взаимодействие между различными модулями или компонентами системы. <br>
					Основная цель интеграционного тестирования — убедиться, что модули, которые корректно работают по отдельности, взаимодействуют между собой так, как это предусмотрено проектом. <br>
					<h4>Основные задачи Integration Testing:</h4>
						1. Проверить корректность обмена данными между модулями.<br>
						2. Обнаружить дефекты, возникающие на стыках взаимодействия модулей.<br>
						3. Убедиться, что интеграция с внешними системами или сервисами проходит успешно.<br>
						4. Оценить, как работает система в целом после объединения модулей.<br>
						
					<h4>Когда проводится Integration Testing:</h4>
						1. После того, как модули или компоненты успешно протестированы на уровне Unit Testing (модульного тестирования).<br>
						2. До системного тестирования, которое охватывает всю систему целиком.<br>
							
					<h4>Подходы к Integration Testing:</h4>
						1. Big Bang Testing (Большой взрыв):<br>
							1.1. се модули интегрируются одновременно, а затем тестируются как единое целое.<br>
							1.2. Преимущества: Простота реализации.<br>
							1.3. Недостатки: Сложность в определении причин ошибок, если что-то не работает.<br>
						2. Incremental Testing (Инкрементальное тестирование):<br>
							2.1. Модули объединяются и тестируются поэтапно.<br>
								2.1.1. Делится на два подхода:<br>
									2.1.1.1. Top-Down (Сверху вниз):<br>
										2.1.1.1.1 Интеграция начинается с высокоуровневых модулей, постепенно добавляются низкоуровневые.<br>
										Преимущества: Логика системы тестируется сразу.<br>
										Недостатки: Может потребоваться использование заглушек для низкоуровневых модулей.<br>
									2.1.1.1. Bottom-Up (Снизу вверх):<br>
										2.1.1.1.1 Сначала объединяются и тестируются низкоуровневые модули, затем высокоуровневые.<br>
										Преимущества: Не нужны заглушки.<br>
										Недостатки: Высокоуровневая логика тестируется позже.<br>
						3. Sandwich Testing (Сэндвич-тестирование):<br>
							3.1. Комбинация подходов Top-Down и Bottom-Up.<br>
							3.2. Разные уровни интегрируются и тестируются параллельно.<br>
						4. Continuous Integration Testing (Непрерывное тестирование интеграции):
							4.1. Интеграция и тестирование происходят автоматически после каждого изменения кода.<br>
							4.2. Популярен в проектах, использующих практики CI/CD.<br>
				</div>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					<strong>Нефункциональное тестирование (производительность, безопасность, юзабилити)</strong>
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>Нефункциональное тестирование</strong> - это тип тестирования программного обеспечения, который проверяет аспекты системы, не связанные с конкретной функциональностью, такие как производительность,  юзабилити и безопасность. Оно направлено на то, чтобы убедиться, что система удовлетворяет нефункциональным требованиям и обеспечивает качественный пользовательский опыт.<br>
				</div>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Performance Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Performance Testing - Проверить, насколько эффективно система справляется с нагрузкой.
					<h4>Примеры:</h4>
						1. Измерение времени загрузки веб-страницы при обычной нагрузке.<br>
						2. Проверка скорости обработки данных для отчётов.<br>
						3. Оценка времени отклика API при множественных запросах.<br>
							
					<h4>Подвиды:</h4>
						1. Load Testing: Проверка системы при обычной или немного повышенной нагрузке. Пример: 100 пользователей одновременно оформляют заказы.<br>
						2. Stress Testing: Проверка поведения системы за пределами нормальной нагрузки. Пример: 10 000 пользователей пытаются войти в систему одновременно.<br>
						3. Spike Testing: Проверка реакции системы на внезапное увеличение нагрузки. Пример: Вирусный пост приводит к мгновенному росту посетителей сайта.<br>
						4. Endurance Testing: Тестирование устойчивости при длительной нагрузке. Пример: Сервер работает под постоянной нагрузкой в течение 72 часов.<br>
					<h4><i>Занимался Load Testing при помощи JMeter(давно) и при помощи Postman не так давно, иногда при проведении Load Testing выяснялось что это Stress Testing)) Не занимался проверкой баланса там когда сервера сами поднимаются и гаснут в зависимости от нагрузки</i></h4>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Security testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Security testing - Проверить защищенность приложения от угроз и атак.
					<h4>Примеры:</h4>
						1. Проверка доступа к ресурсам без авторизации.<br>
						2. Проверка устойчивости к SQL-инъекциям. (нужно экранировать данные которые вводит, загружает пользователь или делать маску что б этого не случалось)<br>
						3. Тестирование сильных и слабых сторон авторизации и аутентификации (например, двухфакторная аутентификация).<br>
						4. Оценка шифрования данных (например, в банковском приложении).<br>
						
					<h4><i>Проверка доступа без авторизации, то что экспайрятся токены. Авторизация.</i></h4>
					<h4>Подвиды:</h4>
						1. Load Testing: Проверка системы при обычной или немного повышенной нагрузке. Пример: 100 пользователей одновременно оформляют заказы.<br>
						2. Stress Testing: Проверка поведения системы за пределами нормальной нагрузки. Пример: 10 000 пользователей пытаются войти в систему одновременно.<br>
						3. Spike Testing: Проверка реакции системы на внезапное увеличение нагрузки. Пример: Вирусный пост приводит к мгновенному росту посетителей сайта.<br>
						4. Endurance Testing: Тестирование устойчивости при длительной нагрузке. Пример: Сервер работает под постоянной нагрузкой в течение 72 часов.<br><br>
				</div>
			</div>

			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Usability testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Usability testing - Убедиться, что интерфейс приложения удобен и интуитивно понятен для пользователей.
					<h4>Примеры:</h4>
						1. Проверка логичности навигации на сайте интернет-магазина.<br>
						2. Изучение времени, требуемого пользователю, чтобы найти нужную информацию.<br>
						3. Оценка дизайна и контрастности интерфейса для людей с нарушением зрения.<br>
						4. Проверка корректности отображения интерфейса на разных устройствах.<br>
							
					<h4><i>Мы использовали какой то сервис по аналитике, который записывал видео "что делают пользователи". Отсматривали эти видео и с дизайнером искали решение этой проблемы</i></h4>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Тестирование совместимости (Compatibility Testing)
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Compatibility Testing - Проверить работу системы в различных окружениях (ОС, браузеры, устройства).
					<h4>Примеры:</h4>
						1. Тестирование сайта в разных браузерах (Chrome, Safari, Edge).<br>
						2. Проверка работы приложения на Windows, macOS и Linux.<br>
						3. Тестирование отображения контента на смартфонах с разными разрешениями экранов.<br>
							
					<h4><i>Для тестирования разрешения использовал DevTool в хроме, Perfiect Pixel если надо было пиксель в пиксель где то сделать. по браузерам начинал с IE6 так что мне ничего не страшно в этой жизни)) Сафари / Chrome на iPhone, iPad. Linux не смотрел никогда не было проектов в которых это было надо. Раньше в FireFox смотрел, потом тоже как то не было проектов где на это надо время тратить. Программы типа BrowserStack не использовал. Эмуляторы разные для девайсов тоже не использовал. Андройд или очень давно или +- никогда не тестировал, iOS много тестировал</i></h4>
				</div>
			</div>
			
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Тестирование локализации (Localization Testing)
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Localization Testing - Убедиться, что продукт правильно адаптирован к локальным рынкам (языки, валюты, культурные особенности).
					<h4>Примеры:</h4>
						1. Проверка правильности перевода интерфейса на испанский.<br>
						2. Тестирование отображения цен в евро для европейских пользователей.<br>
						3. Проверка формата даты и времени для Японии (годы на основе японской эры).<br>
							
					<h4><i>Date/Time это почти всегда боль, много этим занимался. (в нотификациях, в дате создания/изменения часто неверно отображается по времени локальному пользователя)</i></h4>
				</div>
			</div>

			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Installation Testing
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					Цель Installation Testing - убедиться, что установка, обновление и удаление продукта работают корректно.
					<h4>Примеры:</h4>
						1. Проверка установки программы с минимальными системными требованиями.<br>
						2. Тестирование обновления приложения на новую версию без потери данных.<br>
						3. Проверка полного удаления приложения и связанных файлов.<br>
							
					<h4><i>Тут были приколы когда не доступна для страны APP в AppStore. Очень давно какой то клиент ставили на ПК и там что то проверяли.(15 лет назад)</i></h4>
				</div>
			</div>
		</div>
		
		<h2>Вопросы и ответы</h2>
		<div class="course-goal">
		  <p>Часто задаваемые вопросы и ответы на них</p>
		</div>
		<div class="accordion">
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Чем отличается авторизация от аутентификации ?
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>Аутентификация (Authentication</strong>) - Процесс подтверждения личности пользователя. <strong>Вопрос: "Кто ты?"</strong><br>
						Цель: Убедиться, что пользователь — это тот, за кого он себя выдает.<br>
						Что проверяется: Учетные данные (например, логин и пароль, биометрия, токен).<br>
						Результат: Система подтверждает личность пользователя.<br><br>
						
						Примеры:<br>
						Ввод логина и пароля.<br>
						Использование отпечатка пальца или Face ID.<br>
						Ввод кода из SMS (многофакторная аутентификация).<br><br>
						
					<strong>Авторизация (Authorization)</strong> - Процесс определения прав и доступов пользователя к ресурсам системы. <strong>"Что ты можешь сделать?"</strong><br>
						Цель: Проверить, какие действия или ресурсы разрешены пользователю.<br>
						Что проверяется: Роли, разрешения, политики доступа.<br>
						Результат: Система предоставляет или запрещает доступ к определенным функциям или данным.<br><br>
						
						Примеры:<br>
						Пользователь с ролью "Администратор" может редактировать данные, а с ролью "Пользователь" — только просматривать.<br>
						Доступ к документу только для сотрудников определенного отдела.<br>
						Разрешение на загрузку файлов.<br>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Тестирование черного и белого ящика. Что это и чем отличается
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					1111111111111111
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Токены
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>Токены </strong> — это строки, которые используются для аутентификации и авторизации пользователей или систем при взаимодействии с API. Токен подтверждает, что пользователь или система имеет право на доступ к определенному ресурсу. Различают несколько видов токенов:<br>
						0. Access Token	<br>
							0.1. — это токен, используемый для аутентификации и авторизации пользователя или приложения при доступе к защищенным ресурсам на сервере. Это временный ключ, который подтверждает, что запрос от клиента (пользователя или приложения) авторизован для выполнения действия.<br>
						1. Bearer Token<br>
							1.1. Что это: Токен, который передается в HTTP-заголовке Authorization при отправке запроса.<br>
							Пример использования: Для доступа к защищенным ресурсам API.<br>
							Особенности: Простой в использовании, но если токен скомпрометирован, доступ может быть получен без дополнительной проверки.<br>
							
						2. OAuth Token<br>
							2.1. Что это: Токен, выданный системой аутентификации OAuth (например, Google, Facebook) для авторизации пользователей в сторонних приложениях.<br>
							Пример использования: Пользователь входит в приложение через аккаунт Google или Facebook.<br>
							Особенности: Состоит из двух частей: access token (для доступа) и refresh token (для обновления access token, когда он истекает). Более безопасный вариант, чем обычный Bearer Token.<br>
							
						3. JWT (JSON Web Token)<br>
							3.1. Что это: Токен, который состоит из трех частей: заголовка, полезной нагрузки и подписи.<br>
							Пример использования: Обычно используется для сессий пользователей в веб-приложениях.<br>
							Особенности: Токен подписан и зашифрован, поэтому его можно безопасно передавать, а его подлинность можно проверить.<br>
							
						4. API Key<br>
							4.1. Что это: Токен, который состоит из трех частей: заголовка, полезной нагрузки и подписи.<br>
							Пример использования: Используется для предоставления доступа к API в сервисах, таких как Google Maps, AWS и других.<br>
							Особенности: Часто используется для ограниченного доступа и базовой аутентификации.<br>
							
						5. Session Token<br>
							5.1. Что это: Токен, который создается сервером при аутентификации пользователя и сохраняется на стороне клиента.<br>
							Пример использования: Веб-приложения, где пользователи остаются авторизованными до завершения сессии.<br>
							Особенности: Обычно сохраняется в cookies или локальном хранилище браузера. Он имеет ограниченный срок действия.<br>
							
						6. Refresh Token<br>
							6.1. Что это: Токен, который используется для получения нового access token, когда он истекает.<br>
							Пример использования: Система может выдать refresh token вместе с access token для того, чтобы обновить аутентификацию без повторного ввода данных.<br>
							Особенности: Обеспечивает бесшовный опыт для пользователя, но требует хранения в защищенном виде.<br>
						
						<h4>Где храняться токены ?</h4>
						1.Cookies<br>
							Как это работает: Токен может быть сохранен в cookies, которые автоматически отправляются с каждым запросом к серверу, если указаны соответствующие параметры (например, HttpOnly и Secure).<br>
						2. LocalStorage<br>
							Как это работает: Это хранилище данных, доступное для JavaScript на стороне клиента. Токены могут быть сохранены как строки в localStorage.<br>
						3. SessionStorage<br>
							Как это работает: Токены могут быть сохранены в sessionStorage. Эти данные сохраняются в рамках одной сессии (пока открыта вкладка браузера).<br>
						
					Авторизация (Authorization) - Процесс определения прав и доступов пользователя к ресурсам системы. <strong>"Что ты можешь сделать?"</strong><br>
						Цель: Проверить, какие действия или ресурсы разрешены пользователю.<br>
						Что проверяется: Роли, разрешения, политики доступа.<br>
						Результат: Система предоставляет или запрещает доступ к определенным функциям или данным.<br>
						
						<h4>Примеры:</h4>
						Пользователь с ролью "Администратор" может редактировать данные, а с ролью "Пользователь" — только просматривать.<br>
						Доступ к документу только для сотрудников определенного отдела.<br>
						Разрешение на загрузку файлов.<br>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Cache и Cookies
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>Cookies</strong> — это небольшие текстовые файлы, которые веб-сайты сохраняют на компьютере пользователя для хранения данных. Эти данные могут быть использованы для аутентификации, хранения настроек и предпочтений пользователя, отслеживания сессий и персонализации контента.<br>
						Основные характеристики cookies:<br>
							1. Сохранение на клиентской стороне: Куки хранятся в браузере пользователя, обычно в виде текстового файла, который включает пару ключ-значение.<br>
							2. Использование:<br>
								2.1. Куки используются для: Аутентификации пользователя (например, хранение токенов или идентификаторов сессий).<br>
								2.2. Куки используются для: Персонализации интерфейса и хранения настроек (например, язык интерфейса).<br>
								2.3. Куки используются для: Отслеживания активности пользователя для аналитики или рекламы.<br>
							3. Срок действия:<br>
								3.1. Сессионными (session cookies) — удаляются, когда пользователь закрывает браузер.<br>
								3.2. Постоянными (persistent cookies) — сохраняются на устройстве на заданный срок (например, до определенной даты).<br>
							4. Типы cookies:<br>
								4.1. First-party cookies — создаются и используются сайтом, который вы посещаете.<br>
								4.2. Third-party cookies — создаются сторонними сайтами, например, рекламными сервисами, и могут использоваться для отслеживания на разных сайтах.<br>
							5. Параметры cookies:<br>
								5.1. HttpOnly — делает cookie доступным только через HTTP-запросы, предотвращая доступ из JavaScript, что помогает защитить от XSS-атак.<br>
								5.2. Secure — cookie будет отправляться только по защищенному протоколу HTTPS.<br>
								5.3. SameSite — контролирует, когда cookie может быть отправлено (например, ограничивает отправку в межсайтовых запросах, чтобы предотвратить CSRF-атаки).<br>
								
					<strong>Кэш (Cache)</strong> — это место для хранения временных данных, чтобы ускорить доступ к часто используемым данным или ресурсам. Кэш может использоваться как на стороне клиента (в браузере), так и на стороне сервера для улучшения производительности.<br>
						Основные характеристики кэша:<br>
							1. Типы кэша:<br>
								1.1. Браузерный кэш (Client-side cache): Веб-браузеры хранят кэшированные ресурсы (например, HTML, CSS, JavaScript, изображения), чтобы избежать повторной загрузки этих файлов при следующих посещениях того же сайта.<br>
								1.2. Серверный кэш: На сервере могут храниться кэшированные данные (например, результаты запросов к базе данных или сгенерированные страницы), чтобы ускорить ответ на часто повторяющиеся запросы.<br>
							2. Использование:<br>
								2.1. Кэш помогает ускорить загрузку страниц, уменьшая необходимость повторной загрузки ресурсов из сети.<br>
								2.2. Применяется для хранения изображений, скриптов, стилей и других статических файлов.<br>	
							3. Срок действия:<br>
								3.1. Кэшированные ресурсы имеют срок действия, после которого они должны быть повторно загружены. Это определяется заголовками, такими как Cache-Control или Expires.<br>
							4. Типы кэширования:<br>
								4.1. Кэширование браузером (Browser Cache): Браузер сохраняет копии статических ресурсов на устройстве пользователя для ускоренной загрузки при повторном посещении сайта.<br>
								4.2. Кэширование с помощью CDN: Сетевые ресурсы (например, изображения, видео, стили) могут кэшироваться на серверах по всему миру, ускоряя доступ к ним.<br>
								4.3. API кэширование: Серверы могут кэшировать результаты запросов к API для ускорения обработки часто запрашиваемых данных.<br>
							5. Заголовки кэширования:<br>
								5.1. Cache-Control — управляет кешированием на клиенте и сервере (например, no-store, max-age).<br>
								5.2. Expires — указывает дату, до которой данные могут быть использованы из кэша.<br>
								5.3. ETag и Last-Modified — используются для проверки актуальности кэшированных данных.<br>
					<strong>В сумме, cookies — это инструмент для хранения данных, связанных с сессиями и пользователем, в то время как cache помогает ускорить доступ к статическим файлам и данным.</strong>
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					DB Query
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					4444444444444444
				</div>
			</div>

			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					Postman
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<h4>Коллекции в Postman</h4>
					Коллекции в Postman — это организованные наборы API-запросов, которые помогают структурировать и упрощать работу с тестированием API.
					Основные аспекты:
						1. Организация запросов:<br>
							1.1. Запросы группируются по логике: функциональности, эндпоинтам или этапам тестирования.<br>
							1.2. Например, коллекция может содержать запросы для авторизации, CRUD-операций, проверки ошибок.<br>
						2. Переменные:<br>
							2.1. Можно использовать переменные (глобальные, коллекции, окружения) для упрощения настройки (например, базовый URL, токены).<br>
						3. Тесты и скрипты:<br>
							3.1. Можно писать скрипты на JavaScript на уровне запроса или всей коллекции для проверки ответов или выполнения предварительных условий.<br>
						4. Шаринг:<br>
							4.1. Коллекции можно экспортировать и делиться ими с другими членами команды.<br>
						5. Автоматизация:<br>
						Коллекции поддерживают запуск через Postman Runner или CI/CD для автоматического тестирования.
					Пример использования:
						1. Создайте коллекцию для API-приложения, добавьте запросы (GET, POST, PUT, DELETE) и настройте базовый URL через переменную окружения.<br>
						2. Настройте тестовые скрипты, чтобы проверять статус-коды, тела ответов и заголовки.<br>
					<h4>Pre/Post Request</h4>
						var jsonData = pm.response.json();<br>
						pm.environment.set('thread_uuid_q1', jsonData.uuid);<br>
					Этот код написан для работы в Postman — популярном инструменте для тестирования API. Давай разберем, что здесь происходит простыми словами:</strong><br>
						1. var jsonData = pm.response.json();<br>
							Здесь Postman берет ответ от API (response) и превращает его в объект JavaScript.<br>
							Например, если API возвращает такой JSON:<br>
								{<br>
								  "uuid": "12345-abcde-67890"<br>
								}<br>
							то после этой строки jsonData будет выглядеть так:
								{<br>
								  uuid: "12345-abcde-67890"<br>
								}<br>
						2. pm.environment.set('thread_uuid_q1', jsonData.uuid);<br>
							Здесь из объекта jsonData берется значение поля uuid (например, "12345-abcde-67890").<br>
							Это значение сохраняется в переменную окружения с именем 'thread_uuid_q1'.<br>
							Переменная окружения — это способ сохранить данные в Postman, чтобы использовать их позже в других запросах или тестах.<br>
						
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					JavaScript
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					6666666666666
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					GPT
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					77777777777777
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					CI/CD
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					88888888888888
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					SDLC
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					99999999999999
				</div>
			</div>
			<div class="accordion-item">
				<div class="accordion-title" onclick="toggleAccordion(event)">
					HTTP
					<i class="fas fa-chevron-down accordion-icon"></i>
				</div>
				<div class="accordion-content">
					<strong>HTTP (HyperText Transfer Protocol)</strong> — это протокол передачи гипертекста, который используется для обмена данными между клиентом (например, браузером) и сервером в интернете. <br>
					HTTP описывает, как сообщения должны быть формулированы и передаваться, а также как серверы и клиенты должны реагировать на различные команды. <br>						
					<h4>Основные принципы работы HTTP:</h4>
					1. Клиент-серверная модель: HTTP работает по модели клиент-сервер, где клиент (например, браузер) отправляет запросы к серверу, а сервер отвечает на эти запросы, предоставляя данные (например, веб-страницы, изображения, файлы и т. д.).<br>
					2. Запросы и ответы:<br>
					HTTP-сообщения делятся на запросы и ответы:<br>
						2.1. Запрос: Клиент (например, браузер) отправляет запрос к серверу.<br>
						2.2. Ответ: Сервер обрабатывает запрос и возвращает клиенту ответ с нужной информацией.<br>
					3. Статус кодов:
					Ответы сервера содержат статусные коды, которые информируют клиента о результате запроса. Например:<br>
						3.1. 200 OK — запрос выполнен успешно.<br>
						3.2. 404 Not Found — страница не найдена.<br>
						3.3. 500 Internal Server Error — ошибка на сервере.<br>
					4. Без состояния (Stateless):<br>
						4.1. HTTP является беспомощным (stateless), что означает, что сервер не хранит информацию о предыдущих запросах. Каждый запрос рассматривается как независимый, и информация о нем не сохраняется между запросами.<br>
					5. Текстовый протокол:<br>
						5.1. HTTP передает данные в текстовом виде, и сообщения запросов и ответов легко читаются человеком. Например, HTTP-запрос состоит из строки запроса (например, GET /index.html HTTP/1.1), заголовков и тела.<br>
						
					<h4>Основные компоненты HTTP-запроса:</h4>
						1. Метод запроса (HTTP method):<br>
						Определяет, какое действие требуется выполнить над ресурсом. Основные методы:<br>
							1. GET — извлечь данные с сервера.<br>
							2. POST — отправить данные на сервер.<br>
							3. PUT — обновить данные на сервере.<br>
							4. DELETE — удалить данные с сервера.<br>
						2. URL (Uniform Resource Locator):<br>
						Указывает местоположение ресурса на сервере, например, https://www.example.com/index.html.<br>
							2.1. Запрос: Клиент (например, браузер) отправляет запрос к серверу.<br>
							2.2. Ответ: Сервер обрабатывает запрос и возвращает клиенту ответ с нужной информацией.<br>
						3. Заголовки (Headers):<br>
						Содержат метаинформацию о запросе или ответе, например, тип содержимого (Content-Type), язык (Accept-Language), информация о сессии (Cookies).<br>
						4. Тело запроса или ответа (Body):<br>
							Содержит данные, которые отправляются или получаются. Например, в случае метода POST это могут быть данные формы, а в случае ответа — HTML-контент или изображения.

					<strong>HTTPS (HTTP Secure):</strong><br>
						Это защищенная версия HTTP, использующая SSL/TLS для шифрования данных между клиентом и сервером. HTTPS защищает конфиденциальность и целостность передаваемой информации, что особенно важно при передаче чувствительных данных, таких как пароли или номера кредитных карт.<br>
				</div>
				<div class="accordion-item">
					<div class="accordion-title" onclick="toggleAccordion(event)">
						API
						<i class="fas fa-chevron-down accordion-icon"></i>
					</div>
					<div class="accordion-content">
						4444444444555555
					</div>
				</div>
			</div>
		</div>
	</div>
	<div class="icon-container">
		<a href="/course/map-7.html" class="yellow" title="Map">M</a>
		<a href="/course/helps/landing-slides.html" class="gray" title="Слайды">S</a>
		<a href="/course/helps/landing-scenario.html" class="blue" target="_blank" title="Сценарий">T</a>
	</div>
</body>
</html>
